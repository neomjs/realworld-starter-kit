"use strict";
(self["webpackChunkneo_mjs_realworld_example_app"] = self["webpackChunkneo_mjs_realworld_example_app"] || []).push([["vendors-node_modules_neo_mjs_src_data_connection_WebSocket_mjs"],{

/***/ "./node_modules/neo.mjs/src/data/connection/WebSocket.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/neo.mjs/src/data/connection/WebSocket.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./node_modules/neo.mjs/src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./node_modules/neo.mjs/src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    static getStaticConfig() {return {
        /**
         * True automatically applies the core.Observable mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         */
        socket_: null
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket();
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            me.createSocket();

            callback && me.on('open', {
                callback,
                scope : scope || me,
                single: true
            });
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me      = this,
            channel = me.channel;

        console.log('WS: Sending message', (channel ? '\nChannel: ' + channel : ''), '\nData:', data);

        return JSON.stringify(channel ? {channel, data} : data);
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createInterceptor(value, 'send', me.beforeSend, me);
        }

        return value;
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason);
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress);
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args);
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        console.log('onClose', event, reason, wasClean);
    }

    /**
     *
     */
    onError() {
        console.log('onError', arguments);
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        console.log('onMessage', data);

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId];
        }
    }

    /**
     *
     */
    onOpen() {
        this.fire('open', {scope: this});
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++;
        });
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me     = this,
            socket = me.socket,
            d      = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d);
                }, me, {single: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

Neo.applyClassConfig(Socket);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Socket);


/***/ }),

/***/ "./node_modules/neo.mjs/src/util/Function.mjs":
/*!****************************************************!*\
  !*** ./node_modules/neo.mjs/src/util/Function.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");


/**
 * @class Neo.util.Function
 * @extends Neo.core.Base
 */
class NeoFunction extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.util.Function'
         * @protected
         */
        className: 'Neo.util.Function'
    }}

    /**
     * Append args instead of prepending them
     * @param {Object} scope
     * @returns {Function}
     */
    static bindAppend(scope) {
        const fn   = this,
              args = [].slice.call(arguments).slice(1);

        return function() {
            return fn.apply(scope, [].slice.call(arguments).concat(args));
        }
    }

    /**
     * Intended for functions with 1 param where the interceptor can change the value
     * @param {Object} target
     * @param {String} targetMethodName
     * @param {Function} interceptFunction
     * @param {Object} scope=target
     * @returns {Function}
     */
    static createInterceptor(target, targetMethodName, interceptFunction, scope) {
        let targetMethod = target[targetMethodName];

        return (target[targetMethodName] = function(value) {
            return targetMethod.call(target, interceptFunction.call(scope || target, value));
        });
    }

    /**
     * @param {Neo.core.Base} target
     * @param {String} methodName
     * @param {Function} fn
     * @param {Object} scope
     * @returns {Function}
     */
    static createSequence(target, methodName, fn, scope) {
        let method = target[methodName] || Neo.emptyFn;

        return (target[methodName] = function() {
            method.apply(this, arguments);
            return fn.apply(scope || this, arguments);
        });
    }

    /**
     * The interceptor can prevent the targetMethod from getting executed in case it returns false.
     * @param {Object} target
     * @param {String} targetMethodName
     * @param {Function} interceptFunction
     * @param {Object} scope=target
     * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
     * @returns {Function}
     */
    static intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
        let targetMethod = target[targetMethodName];

        return (target[targetMethodName] = function() {
            return (interceptFunction.apply(scope || target, arguments) === false)
                ? preventedReturnValue
                : targetMethod.apply(target, arguments);
        });
    }
}

Neo.applyClassConfig(NeoFunction);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NeoFunction);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2RhdGEvdmVuZG9ycy1ub2RlX21vZHVsZXNfbmVvX21qc19zcmNfZGF0YV9jb25uZWN0aW9uX1dlYlNvY2tldF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNJO0FBQ0U7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixZQUFZLDRFQUE2QjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpELDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLE1BQU0sRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hRYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUk7QUFDOUIsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMtcmVhbHdvcmxkLWV4YW1wbGUtYXBwLy4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL2RhdGEvY29ubmVjdGlvbi9XZWJTb2NrZXQubWpzIiwid2VicGFjazovL25lby5tanMtcmVhbHdvcmxkLWV4YW1wbGUtYXBwLy4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL3V0aWwvRnVuY3Rpb24ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9GdW5jdGlvbiBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgZnJvbSAnLi4vLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjaGFubmVsPW51bGxcbiAgICAgKi9cbiAgICBjaGFubmVsID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4UmVjb25uZWN0QXR0ZW1wdHM9NVxuICAgICAqL1xuICAgIG1heFJlY29ubmVjdEF0dGVtcHRzID0gNVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVzc2FnZUNhbGxiYWNrcz17fVxuICAgICAqL1xuICAgIG1lc3NhZ2VDYWxsYmFja3MgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWVzc2FnZUlkPTFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVzc2FnZUlkID0gMVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gcmVjb25uZWN0QXR0ZW1wdHM9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWNvbm5lY3RBdHRlbXB0cyA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2VydmVyQWRkcmVzcz1udWxsXG4gICAgICovXG4gICAgc2VydmVyQWRkcmVzcyA9IG51bGxcblxuICAgIHN0YXRpYyBnZXRTdGF0aWNDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIG9ic2VydmFibGU6IHRydWVcbiAgICB9fVxuXG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzb2NrZXQtY29ubmVjdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzb2NrZXQtY29ubmVjdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJTb2NrZXR8bnVsbH0gc29ja2V0Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvY2tldF86IG51bGxcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JlYXRlU29ja2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKi9cbiAgICBhdHRlbXB0UmVjb25uZWN0KGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnJlY29ubmVjdEF0dGVtcHRzKys7XG5cbiAgICAgICAgaWYgKG1lLnJlY29ubmVjdEF0dGVtcHRzIDwgbWUubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZVNvY2tldCgpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBtZS5vbignb3BlbicsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBzY29wZSA6IHNjb3BlIHx8IG1lLFxuICAgICAgICAgICAgICAgIHNpbmdsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcmNlcHRzIHRoZSBXZWJTb2NrZXQgc2VuZCBjYWxsc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2hhbm5lbCA9IG1lLmNoYW5uZWw7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1dTOiBTZW5kaW5nIG1lc3NhZ2UnLCAoY2hhbm5lbCA/ICdcXG5DaGFubmVsOiAnICsgY2hhbm5lbCA6ICcnKSwgJ1xcbkRhdGE6JywgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNoYW5uZWwgPyB7Y2hhbm5lbCwgZGF0YX0gOiBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzb2NrZXQgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7V2ViU29ja2V0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1dlYlNvY2tldHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTb2NrZXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZSwge1xuICAgICAgICAgICAgICAgIG9uY2xvc2UgIDogbWUub25DbG9zZSAgLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uZXJyb3IgIDogbWUub25FcnJvciAgLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9ubWVzc2FnZTogbWUub25NZXNzYWdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9ub3BlbiAgIDogbWUub25PcGVuICAgLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgTmVvRnVuY3Rpb24uY3JlYXRlSW50ZXJjZXB0b3IodmFsdWUsICdzZW5kJywgbWUuYmVmb3JlU2VuZCwgbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gZGVmYXVsdHMgdG8gMTAwMFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVhc29uXVxuICAgICAqL1xuICAgIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlU29ja2V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5zZXJ2ZXJBZGRyZXNzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDbG9zZUV2ZW50fSBldmVudCBUaGUgV2Vic29ja2V0IGdlbmVyYXRlZCBDbG9zZUV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICBldmVudC5jb2RlIFRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZSBjb2RlIHByb3ZpZGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgKlxuICAgICAqICAgICAgICBDb2RlICAgICAgICBOYW1lICAgICAgICAgICAgICAgICAgRGVzY3JpcHRpb25cbiAgICAgKiAgICAgICAgMC05OTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGFuZCBub3QgdXNlZC5cbiAgICAgKiAgICAgICAgMTAwMCAgICAgICAgQ0xPU0VfTk9STUFMICAgICAgICAgIE5vcm1hbCBjbG9zdXJlOyB0aGUgY29ubmVjdGlvbiBzdWNjZXNzZnVsbHkgY29tcGxldGVkIHdoYXRldmVyIHB1cnBvc2UgZm9yIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxuICAgICAqICAgICAgICAxMDAxICAgICAgICBDTE9TRV9HT0lOR19BV0FZICAgICAgVGhlIGVuZHBvaW50IGlzIGdvaW5nIGF3YXksIGVpdGhlciBiZWNhdXNlIG9mIGEgc2VydmVyIGZhaWx1cmUgb3IgYmVjYXVzZSB0aGUgYnJvd3NlciBpcyBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZSB0aGF0IG9wZW5lZCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKiAgICAgICAgMTAwMiAgICAgICAgQ0xPU0VfUFJPVE9DT0xfRVJST1IgIFRoZSBlbmRwb2ludCBpcyB0ZXJtaW5hdGluZyB0aGUgY29ubmVjdGlvbiBkdWUgdG8gYSBwcm90b2NvbCBlcnJvci5cbiAgICAgKiAgICAgICAgMTAwMyAgICAgICAgQ0xPU0VfVU5TVVBQT1JURUQgICAgIFRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIHRlcm1pbmF0ZWQgYmVjYXVzZSB0aGUgZW5kcG9pbnQgcmVjZWl2ZWQgZGF0YSBvZiBhIHR5cGUgaXQgY2Fubm90IGFjY2VwdCAoZm9yIGV4YW1wbGUsIGEgdGV4dC1vbmx5IGVuZHBvaW50IHJlY2VpdmVkIGJpbmFyeSBkYXRhKS5cbiAgICAgKiAgICAgICAgMTAwNCAgICAgICAgQ0xPU0VfVE9PX0xBUkdFICAgICAgIFRoZSBlbmRwb2ludCBpcyB0ZXJtaW5hdGluZyB0aGUgY29ubmVjdGlvbiBiZWNhdXNlIGEgZGF0YSBmcmFtZSB3YXMgcmVjZWl2ZWQgdGhhdCBpcyB0b28gbGFyZ2UuXG4gICAgICogICAgICAgIDEwMDUgICAgICAgIENMT1NFX05PX1NUQVRVUyAgICAgICBSZXNlcnZlZC4gIEluZGljYXRlcyB0aGF0IG5vIHN0YXR1cyBjb2RlIHdhcyBwcm92aWRlZCBldmVuIHRob3VnaCBvbmUgd2FzIGV4cGVjdGVkLlxuICAgICAqICAgICAgICAxMDA2ICAgICAgICBDTE9TRV9BQk5PUk1BTCAgICAgICAgUmVzZXJ2ZWQuIFVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBhYm5vcm1hbGx5ICh0aGF0IGlzLCB3aXRoIG5vIGNsb3NlIGZyYW1lIGJlaW5nIHNlbnQpIHdoZW4gYSBzdGF0dXMgY29kZSBpcyBleHBlY3RlZC5cbiAgICAgKiAgICAgICAgMTAwNy0xOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGJ5IHRoZSBXZWJTb2NrZXQgc3RhbmRhcmQuXG4gICAgICogICAgICAgIDIwMDAtMjk5OSAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBmb3IgdXNlIGJ5IFdlYlNvY2tldCBleHRlbnNpb25zLlxuICAgICAqICAgICAgICAzMDAwLTM5OTkgICAgICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIGZvciB1c2UgYnkgbGlicmFyaWVzIGFuZCBmcmFtZXdvcmtzLiBNYXkgbm90IGJlIHVzZWQgYnkgYXBwbGljYXRpb25zLlxuICAgICAqICAgICAgICA0MDAwLTQ5OTkgICAgICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIGZvciB1c2UgYnkgYXBwbGljYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICByZWFzb24gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcmVhc29uIHRoZSBzZXJ2ZXIgY2xvc2VkIHRoZSBjb25uZWN0aW9uLiBUaGlzIGlzIHNwZWNpZmljIHRvIHRoZSBwYXJ0aWN1bGFyIHNlcnZlciBhbmQgc3ViLXByb3RvY29sLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgd2FzQ2xlYW4gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZC5cbiAgICAgKi9cbiAgICBvbkNsb3NlKGV2ZW50LCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkNsb3NlJywgZXZlbnQsIHJlYXNvbiwgd2FzQ2xlYW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25FcnJvcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uRXJyb3InLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnb25NZXNzYWdlJywgZGF0YSk7XG5cbiAgICAgICAgaWYgKGRhdGEubUlkKSB7XG4gICAgICAgICAgICBtZS5tZXNzYWdlQ2FsbGJhY2tzW2RhdGEubUlkXS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBkZWxldGUgbWUubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1JZF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdvcGVuJywge3Njb3BlOiB0aGlzfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHByb21pc2VNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1ttZS5tZXNzYWdlSWRdID0ge3JlamVjdCwgcmVzb2x2ZX07XG5cbiAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKHtkYXRhLCBtSWQ6IG1lLm1lc3NhZ2VJZH0pO1xuICAgICAgICAgICAgbWUubWVzc2FnZUlkKys7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHNvY2tldCA9IG1lLnNvY2tldCxcbiAgICAgICAgICAgIGQgICAgICA9IGRhdGE7XG5cbiAgICAgICAgLy8gQ09OTkVDVElORyAgMCAgIFRoZSBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgb3Blbi5cbiAgICAgICAgLy8gT1BFTiAgICAgICAgMSAgIFRoZSBjb25uZWN0aW9uIGlzIG9wZW4gYW5kIHJlYWR5IHRvIGNvbW11bmljYXRlLlxuICAgICAgICAvLyBDTE9TSU5HICAgICAyICAgVGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cbiAgICAgICAgLy8gQ0xPU0VEICAgICAgMyAgIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBvciBjb3VsZG4ndCBiZSBvcGVuZWQuXG5cbiAgICAgICAgLy8gSWYgc29ja2V0IGlzIG5vdCB5ZXQgcmVhZHkgbGV0J3MgZGVmZXIgdG8gb3BlbiB0aGVuIHJlc2VuZFxuICAgICAgICBzd2l0Y2ggKHNvY2tldC5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DTE9TRUQ6XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DTE9TSU5HOlxuICAgICAgICAgICAgICAgIG1lLmF0dGVtcHRSZWNvbm5lY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ09OTkVDVElORzpcbiAgICAgICAgICAgICAgICBtZS5vbignb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkKTtcbiAgICAgICAgICAgICAgICB9LCBtZSwge3NpbmdsZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuT1BFTjpcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoU29ja2V0KTtcblxuZXhwb3J0IGRlZmF1bHQgU29ja2V0O1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkZ1bmN0aW9uXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE5lb0Z1bmN0aW9uIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGdldENvbmZpZygpIHtyZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkZ1bmN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5GdW5jdGlvbidcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFyZ3MgaW5zdGVhZCBvZiBwcmVwZW5kaW5nIHRoZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICovXG4gICAgc3RhdGljIGJpbmRBcHBlbmQoc2NvcGUpIHtcbiAgICAgICAgY29uc3QgZm4gICA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVuZGVkIGZvciBmdW5jdGlvbnMgd2l0aCAxIHBhcmFtIHdoZXJlIHRoZSBpbnRlcmNlcHRvciBjYW4gY2hhbmdlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0TWV0aG9kTmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRhcmdldFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW50ZXJjZXB0b3IodGFyZ2V0LCB0YXJnZXRNZXRob2ROYW1lLCBpbnRlcmNlcHRGdW5jdGlvbiwgc2NvcGUpIHtcbiAgICAgICAgbGV0IHRhcmdldE1ldGhvZCA9IHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXTtcblxuICAgICAgICByZXR1cm4gKHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0TWV0aG9kLmNhbGwodGFyZ2V0LCBpbnRlcmNlcHRGdW5jdGlvbi5jYWxsKHNjb3BlIHx8IHRhcmdldCwgdmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXF1ZW5jZSh0YXJnZXQsIG1ldGhvZE5hbWUsIGZuLCBzY29wZSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gdGFyZ2V0W21ldGhvZE5hbWVdIHx8IE5lby5lbXB0eUZuO1xuXG4gICAgICAgIHJldHVybiAodGFyZ2V0W21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShzY29wZSB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJjZXB0b3IgY2FuIHByZXZlbnQgdGhlIHRhcmdldE1ldGhvZCBmcm9tIGdldHRpbmcgZXhlY3V0ZWQgaW4gY2FzZSBpdCByZXR1cm5zIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0TWV0aG9kTmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gcHJldmVudGVkUmV0dXJuVmFsdWU9bnVsbCBUaGUgdmFsdWUgdG8gcmV0dXJuIGluIGNhc2UgdGhlIGludGVyY2VwdEZ1bmN0aW9uIHJldHVybnMgZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICovXG4gICAgc3RhdGljIGludGVyY2VwdCh0YXJnZXQsIHRhcmdldE1ldGhvZE5hbWUsIGludGVyY2VwdEZ1bmN0aW9uLCBzY29wZSwgcHJldmVudGVkUmV0dXJuVmFsdWU9bnVsbCkge1xuICAgICAgICBsZXQgdGFyZ2V0TWV0aG9kID0gdGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdO1xuXG4gICAgICAgIHJldHVybiAodGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKGludGVyY2VwdEZ1bmN0aW9uLmFwcGx5KHNjb3BlIHx8IHRhcmdldCwgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgPyBwcmV2ZW50ZWRSZXR1cm5WYWx1ZVxuICAgICAgICAgICAgICAgIDogdGFyZ2V0TWV0aG9kLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhOZW9GdW5jdGlvbik7XG5cbmV4cG9ydCBkZWZhdWx0IE5lb0Z1bmN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9